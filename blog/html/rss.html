<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>Mitkin</title>
        <link>http://mitkin.github.io/</link>
        <description>Misha sings the blues</description>
        <language>en-us</language>
        <pubDate>Fri, 02 Sep 2016 00:00:00 +0200</pubDate>
        
        <item>
            <link>http://mitkin.github.io/2016/09/02/conditional_selection_of_netcdf_indices.html</link>
            <guid>http://mitkin.github.io/2016/09/02/conditional_selection_of_netcdf_indices.html</guid>
            <title><![CDATA[Conditional selection of NetCDF indices (based on time)]]></title>
            <description><![CDATA[<h1>Conditional selection of NetCDF indices (based on time)</h1>
<p>One little thing that I use fairly often but fail to remember is how to make a conditional selection of the steps/indices when retrieving data from a NetCDF file.</p>
<p>A typical reason for selective pulling of the data is to avoid filling memory with the entire dataset when in fact I need only tiny bit of it.</p>
<p>Here are the steps I am doing it at the moment:</p>
<ul class="simple">
<li>Retrieve time information from the array (the time vector is normally much smaller than 3D data I am working with).</li>
<li>Perform selection of the timestamps based on some condition</li>
<li>Use <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.flatnonzero.html">numpy.flatnonzero</a> to return an array mask which is then passed further to the file handler.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>time_array = file.variables['time'][:]
data = file.variables['data'][np.flatnonzero(time_array == '2007)]
</pre></div>
</div>
<p>However this would be too easy. The time information often comes in the format similar to the Unix epoch format, with some offset. Typical format would be ‘seconds since January 1st, 1980’. Few additional steps are necessary to make sure we can apply selection to the data array and maintain the code readable. In my case those are:</p>
<ul class="simple">
<li>Apply offset to the time array to convert it to the standard Unix epoch timestamps</li>
<li>Convert the array to the list of datetime objects</li>
<li>Finally apply your condition</li>
</ul>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first"># apply offset to convert the timestamp to ‘seconds since 1st of January, 1970’
epoch_offset = 252460800
time_array_with_offset = time_array + epoch_offset</p>
<p># convert the array to the list of datetime objects
convert_to_datetime = lambda t: datetime.datetime.fromtimestamp(t)
datetime_list = map(convert_to_datetime, time_array)</p>
<p class="last"># let’s go a bit further an create a list with years only, omit other time information
years_list = map(lambda t: t.year, datetime_list)</p>
</dd>
</dl>
<p>At this point we can finally apply selection by years:</p>
<div class="highlight-python"><div class="highlight"><pre>data = file.variables['data'][np.flatnonzero(years_list == '2007')
</pre></div>
</div>
]]></description>
            <category><![CDATA[ Programming ]]></category>
            <category><![CDATA[ Jots ]]></category>
             <pubDate>Fri, 02 Sep 2016 00:00:00 +0200</pubDate>
        </item>
    
        <item>
            <link>http://mitkin.github.io/2016/08/30/book_first_steps_towards_ci.html</link>
            <guid>http://mitkin.github.io/2016/08/30/book_first_steps_towards_ci.html</guid>
            <title><![CDATA[Book: First steps towards CI]]></title>
            <description><![CDATA[<h1>Book: First steps towards CI</h1>
<p>Browsing twitter I stubmbled upon an interesting <a class="reference external" href="https://leanpub.com/deploy">book</a>:</p>
<blockquote>
<div>Reliable and Fast Deployments Through Automation
Your first steps towards Continuous Delivery</div></blockquote>
<p>The book is an introduction into the principles of continious integration (CI) practices, gives a summary of what are the benefits and pitfalls of CI.
It starts with the basic approaches like <span class="docutils literal"><span class="pre">`git</span> <span class="pre">pull`</span></span> and finishes with the deploying Ansible playbooks in the network sandbox managed by Vagrant.</p>
<p>I feel that the material is aimed at the public that is looking for where to start with the CI. The more advanced audience might find some of the chapters helpful (I personally always struggle to remember how to build Debian packages).</p>
]]></description>
            <category><![CDATA[ Books ]]></category>
             <pubDate>Tue, 30 Aug 2016 00:00:00 +0200</pubDate>
        </item>
    
        <item>
            <link>http://mitkin.github.io/2015/12/17/hello_world.html</link>
            <guid>http://mitkin.github.io/2015/12/17/hello_world.html</guid>
            <title><![CDATA[Bayesian Methods for Hackers]]></title>
            <description><![CDATA[<h1>Bayesian Methods for Hackers</h1>
<blockquote>
<div>You are a skilled programmer, but bugs still slip into your code. After a particularly difficult implementation of an algorithm, you decide to test your code on a trivial example. It passes. You test the code on a harder problem. It passes once again. And it passes the next, even more difficult, test too! You are starting to believe that there may be no bugs in this code...
If you think this way, then congratulations, you already are thinking Bayesian! Bayesian inference is simply updating your beliefs after considering new evidence. A Bayesian can rarely be certain about a result, but he or she can be very confident. Just like in the example above, we can never be 100% sure that our code is bug-free unless we test it on every possible problem; something rarely possible in practice. Instead, we can test it on a large number of problems, and if it succeeds we can feel more confident about our code, but still not certain. Bayesian inference works identically: we update our beliefs about an outcome; rarely can we be absolutely sure unless we rule out all other alternatives.</div></blockquote>
<p>If you are into Bayesian statistics and applying those principled to the code you develop, this <a class="reference external" href="http://nbviewer.jupyter.org/github/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/blob/master/Chapter1_Introduction/Chapter1.ipynb">book</a> is a must read. Seriously good introduction into Bayesian statistics with application to computational problems and <a class="reference external" href="https://pymc-devs.github.io/pymc">PyMC</a>, a python Bayesian statistics module.</p>
]]></description>
            <category><![CDATA[ Books ]]></category>
             <pubDate>Thu, 17 Dec 2015 00:00:00 +0100</pubDate>
        </item>
    
    </channel>
</rss>